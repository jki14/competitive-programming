<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <title>TopCoder 2019 Humblefool Prelim - 300: SwappingNodes</title>
    
    <link type="image/x-icon" rel="shortcut icon" href="http://www.topcoder.com/i/favicon.ico"/>
    

    
    <style type="text/css">
        /* font */
body {
    font-family: Helvetica, Arial, Verdana, sans-serif;
    font-size: 16px;
    line-height: 1.2em;
}
ul.constraints > li:before, ul.notes > li:before {
    font-family: monospace;
    font-weight: normal;
}
.heading {
    font-weight: bold;
    font-size: 175%;
    line-height: 1.2em;
}
.section .section-title {
    font-weight: bold;
    font-size: 125%;
}
ol.testcases > li:before {
    font-family: monospace;
}
type {
    font-weight: bold;
    font-family: monospace;
}
li.testcase .data {
    font-family: monospace;
    line-height: 1.5em;
}

/* layout */
.heading {
    margin-top: 0.1em;
    margin-bottom:0.1em;
    text-align: center;
}
.section .section-title {
    margin-top : 1em;
    margin-bottom: 1em;
}
.problem-intro, note, user-constraint {
    padding-left: 1.25em;
}

/* Lists */
ul.constraints, ul.notes, ul.variables, ul.problem-definition-lines {
    list-style-type: none;
    padding: 0px;
}
ul.constraints > li:before {
    content: "-";
    position:relative;
    margin-left: 0px; /* optional, for multiline li element */
    left: 0.625em;
}
ul.notes > li:before {
    content: "-";
    position:relative;
    margin-left: 0px; /* optional, for multiline li element */
    left: 0.625em;
}

/* Testcases */
li.testcase {
    line-height: 1.1em;
    padding-top: 0.625em;
    padding-bottom: 0.625em;
    overflow: auto;
}
li.testcase > .testcase-content > div { padding-bottom: 0.5em; padding-left: 1em; }

li.testcase .testcase-comment {
    margin: 0;
    padding-left: 1em;
}
.testcase-comment p:first-child { margin-top: 0; }
.testcase-comment p:last-child { margin-bottom: 0; }

li.testcase .testcase-content {
    margin: 0.31em;
}

/* Data and variables */
.testcase-output {
    padding: 0.2em 1em 0.2em 0em;
}
.variables, .testcase-output {
    margin-left: 0.5em;
    display: table;
    margin-bottom: 0px;
    margin-top: 0px;
}
.variable {
    display: table-row;
}
.variable .name {
    padding: 0.2em 0em 0.2em 1em;
    font-weight: bold;
    display: table-cell;
    text-align: right;
}
.testcase-output .prefix {
    padding: 0.2em 0em 0.2em 1em;
    display: table-cell;
}
.testcase-output .prefix:after {
    content : ":";
    padding-right: 0.5em;
}
.variable .name:after {
    font-weight: bold;
    content : ":";
    padding-right: 0.5em;
}
.variable .value, .testcase-output .value {
    padding: 0.2em 1em 0.2em 0em;
    display: table-cell;
}
ol.testcases {
    padding: 0px;
    counter-reset: test_number -1;
}
ol.testcases > li {
    list-style:none;
}
ol.testcases > li:before {
    counter-increment:test_number;
    display: block;
    clear: both;
    content:counter(test_number) ")";
    color: inherit;
    background: inherit;
}

/* Problem Definition */
.problem-definition, .problem-limits {
    padding-left: 1.25em;
}
.problem-definition-lines, .limit-lines {
    display: table;
    margin-top: 0px;
    margin-bottom: 0px;
    padding-left: 0px;
}
.definition-line, .limit-line {
    display: table-row;
    height: 1.5em;
    overflow: auto;
}
.limit-name:after {
    content: ":";
    margin-right: 1em;
}
.definition-name, .definition-value, .limit-name, .limit-value {
    display: table-cell;
}
.definition-value {
    padding-left: 0.5em;
}
.definition-name:after {
    content: ":";
}
#contest-division:before {
    content: "Div ";
}
#problem-score:before {
    content: "- Problem ";
}
#problem-name {
    display: block;
}

/* Tags, hidden default */
.tag {
    visibility: hidden;
    position: absolute;
}

        body {
    /* font color */
    color: #333333;
    /* background color */
    background-color: white;
}
.section .section-title {
    /* title color */
    color: black;
}
li.testcase .data {
    /* highlight color */
    background: #eee;
}

    </style>
    
    
    

</head>

<body>
    <h1 class="heading">
        <span id='contest-name'>2019 Humblefool Prelim</span>
        <span id='contest-division'>1</span>
        <span id='problem-score'>300</span>
        <span id='problem-name'>SwappingNodes</span>
    </h1>

    <hr />

    <!-- Problem Statement -->
    <div class="section">
        <h2 class="section-title">Problem Statement</h2>
        <div class="problem-intro">
            <intro escaped="1"><p>
We have a full binary tree.
That is, we have a rooted tree in which all leaves have the same depth, and each node that is not a leaf has exactly one left child and one right child.
Each leaf of our tree contains a positive integer, and these integers are distinct.
</p>
<p>
As an example, the figure below shows a full binary tree with four leaves:
</p>
<pre>
                              ________C________
                             /                 \
                        ____A____           ____B____ 
                       /         \         /         \
		      5 	  2       1           3
</pre>
<p>
You are given the <type>int[]</type> <b>leaves</b>: the values that are currently stored in the leaves of the tree, read from the left to the right.
For example, for the tree shown above you would be given <b>leaves</b> = {5, 2, 1, 3}.
</p>
<p>
For your convenience, you are also given the <type>int</type> <b>numberOfLeaves</b>.
Its value will be equal to the number of elements in <b>leaves</b>.
</p>
<p>
You are allowed to transform our tree by performing a sequence of steps.
In each step you can select any inner node of the tree and swap its left and right subtrees.
(That is, the left child of the selected node becomes its right child and vice versa.)
You may do arbitrarily many steps, including zero.
You may choose the same node multiple times if you wish.
</p>
<p>
After you are done transforming the tree, we are going to read the values stored in its leaves (again, from the left to the right).
Your task is to make this sequence as small as possible.
Compute and return the lexicographically smallest sequence that can be constructed in the leaves of the tree.
(See Notes for the definition of &quot;lexicographically smaller&quot;.)
</p></intro>
        </div>
    </div>
    
    <!-- Problem definition -->
    
    <div class="section" id="definition">
        <h2 class="section-title">Definition</h2>
        <div class="problem-definition">
            <ul class="problem-definition-lines">
                <li class="definition-line" id='class-line'>
                    <span class='definition-name'>Class</span>
                    <span class='definition-value'>SwappingNodes</span>
                </li>
                <li class="definition-line" id='method-line'>
                    <span class='definition-name'>Method</span>
                    <span class='definition-value'>swapNodes</span>
                </li>
                <li class="definition-line" id='parameters-line'>
                    <span class='definition-name'>Parameters</span>
                    <span class='definition-value'>
                    
                        vector&lt;int&gt;
                    , 
                        int
                    
                    </span>
                </li>
                <li class="definition-line" id='returns-line'>
                    <span class='definition-name'>Returns</span>
                    <span class='definition-value'>
                        vector&lt;int&gt;
                    </span>
                </li>
                <li class="definition-line" id='signature-line'>
                    <span class='definition-name'>Method signature</span>
                    <span class='definition-value'>
                        vector&lt;int&gt; swapNodes(vector&lt;int&gt; leaves, int numberOfLeaves)
                    </span>
                </li>
            </ul>
            <div class="problem-definition-public-tip">(be sure your method is public)</div>
        </div>        
    </div>
    

    <!-- Limits -->
    <div class="section">
        <h2 class="section-title">Limits</h2>
        <div class='problem-limits'>
            <ul class="limit-lines">
                <li class='limit-line'>
                    <span class='limit-name'>Time limit (s)</span>
                    <span class='limit-value'>2.000</span>
                </li>
                <li class='limit-line'>
                    <span class='limit-name'>Memory limit (MB)</span>
                    <span class='limit-value'>256</span>
                </li>
            </ul>
        </div>
    </div>

    
    <!-- Notes -->
    <div class="section">
        <h2 class="section-title">Notes</h2>
        <ul class="notes">
        
            <li><note escaped="1">Given two distinct sequences A = a<sub>0</sub>,a<sub>1</sub>,....a<sub>n-1</sub> and B = b<sub>0</sub>,b<sub>1</sub>,....b<sub>n-1</sub>, the lexicographically smaller sequence is the one that has a smaller value at the first index where they differ. In other words, the sequence A is smaller than the sequence B if for some index x we have (a<sub>x</sub> &lt; b<sub>x</sub>) and (for all i &lt; x : a<sub>i</sub> = b<sub>i</sub>).</note></li>
        
        </ul>
    </div>
    
    
    <!-- Constraints -->
    <div class="section">
        <h2 class="section-title">Constraints</h2>
        <ul class="constraints">
        
            <li><user-constraint escaped="1"><b>leaves</b> will have between 1 and 512 elements, inclusive.</user-constraint></li>
        
            <li><user-constraint escaped="1">The number of elements in <b>leaves</b> will be a power of 2.</user-constraint></li>
        
            <li><user-constraint escaped="1">Each element of <b>leaves</b> will be between 1 and 512, inclusive.</user-constraint></li>
        
            <li><user-constraint escaped="1">All values of <b>leaves</b> will be distinct.</user-constraint></li>
        
            <li><user-constraint escaped="1"><b>numberOfLeaves</b> will be equal to the number of elements in <b>leaves</b>.</user-constraint></li>
        
        </ul>
    </div>

    <!-- Test cases -->
    <div class="section">
        <h2 class="section-title">Test cases</h2>
        <ol class="testcases" start='0'>
            
            <li class="testcase">
                <div class="testcase-content">
                    <div class="testcase-input">
                        <div class='tag'>input</div>
                        <ul class="variables">
                        
                            <li class="variable data">
                                <span class="name data">leaves</span>
                                <span class="value data">
                                
                                    { 5, 2, 1, 3 }
                                
                                </span>
                            </li>
                        
                            <li class="variable data">
                                <span class="name data">numberOfLeaves</span>
                                <span class="value data">
                                
                                    4
                                
                                </span>
                            </li>
                        
                        </ul>
                    </div>
                    <div class="testcase-output">
                        <div class='tag'>output</div>
                        <span class="prefix data">Returns</span>
                        <span class="value data">
                        
                            { 1, 3, 2, 5 }
                        
                        </span>
                    </div>
                    
                    <div class="testcase-annotation">
                        <div class='tag'>note</div>
                        <div class="testcase-comment"><p>
The input describes the tree shown in the problem statement.
</p>
<p>
One optimal solution looks as follows:
</p>
<ol>
<li>Select node C and swap its subtrees. This produces a tree that corresponds to the sequence {1, 3, 5, 2}.</li>
<li>Then, select node A and swap its subtrees. (Note that A is currently the right child of C.) This produces a tree that corresponds to the sequence {1, 3, 2, 5}.</li>
</ol>
<p>
The sequence {1, 3, 2, 5} is the lexicographically smallest of all sequences that can be produced by transforming the tree, and therefore this is the correct return value.
</p></div>
                    </div>
                    
               
                </div>
            </li>
            
            <li class="testcase">
                <div class="testcase-content">
                    <div class="testcase-input">
                        <div class='tag'>input</div>
                        <ul class="variables">
                        
                            <li class="variable data">
                                <span class="name data">leaves</span>
                                <span class="value data">
                                
                                    { 13, 10, 18, 16 }
                                
                                </span>
                            </li>
                        
                            <li class="variable data">
                                <span class="name data">numberOfLeaves</span>
                                <span class="value data">
                                
                                    4
                                
                                </span>
                            </li>
                        
                        </ul>
                    </div>
                    <div class="testcase-output">
                        <div class='tag'>output</div>
                        <span class="prefix data">Returns</span>
                        <span class="value data">
                        
                            { 10, 13, 16, 18 }
                        
                        </span>
                    </div>
                    
                    <div class="testcase-annotation">
                        <div class='tag'>note</div>
                        <div class="testcase-comment"><p>
Here, one optimal solution looks as follows:
</p>
<ol>
<li>Select the left child of the root of the tree. New sequence: {10, 13, 18, 16}.</li>
<li>Then, select the right child of the root of the tree. New sequence: {10, 13, 16, 18}.</li>
</ol>
<p>
Obviously, the sequence we just produced has to be optimal, so we are done.
</p></div>
                    </div>
                    
               
                </div>
            </li>
            
        </ol>
    </div>
    <hr />

    This problem statement is the exclusive and proprietary property of TopCoder, Inc. Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited. (c)2003, TopCoder, Inc. All rights reserved.
</body>
</html>
