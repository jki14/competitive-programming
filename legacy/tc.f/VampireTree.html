<html><body bgcolor="#000000" text="#ffffff"><table><tr><td colspan="2"><h3>Problem Statement</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><p>You are a genealogist specializing in family trees of vampires. Vampire family trees differ from human family trees. In particular, vampires are "born" in a different way. The only way to create a new vampire is that an existing vampire turns a living human into a new vampire. Whenever this happens, we say that the older vampire is the master and the newly created vampire is the servant of that master.</p>

<p>Given a particular family of vampires, the distance between two vampires is the smallest number of steps along the family tree we need to make in order to get from one vampire to the other. Formally, in each step you can move from the current vampire to any of its servants, or to its master (if it has one). Note that for each vampire V the distance between V and V is zero.</p>

<p>You are now studying one particular family of vampires. These vampires have all been created from a single vampire: the True Ancestor. This special vampire has no master. You know that there are n vampires in the family, and you have numbered them 0 through n-1 (in no particular order).</p>

<p>You do not know the master/servant relationships between the vampires in the family. The only information you have is a vector &lt;int&gt; <b>num</b> with n elements. For each valid i, the following statement is true: "If vampire i is the True Ancestor, he has exactly <b>num</b>[i] servants. Otherwise, he has exactly (<b>num</b>[i] - 1) servants."</p>

<p>Consider all valid family trees that are consistent with this information. If there are no such trees, return -1. Otherwise, find and return the maximum distance between any two vampires in any of those family trees. (In other words, for each of the corresponding trees determine the maximum distance, and return the maximum of those maximums.)</p>
</td></tr><tr><td colspan="2"><h3>Definition</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Class:</td><td>VampireTree</td></tr><tr><td>Method:</td><td>maxDistance</td></tr><tr><td>Parameters:</td><td>vector &lt;int&gt;</td></tr><tr><td>Returns:</td><td>int</td></tr><tr><td>Method signature:</td><td>int maxDistance(vector &lt;int&gt; num)</td></tr><tr><td colspan="2">(be sure your method is public)</td></tr></table></td></tr><tr><td colspan="2"><h3>Limits</h3></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td>Time limit (s):</td><td>2.000</td></tr><tr><td>Memory limit (MB):</td><td>256</td></tr></table></td></tr><tr><td colspan="2"><h3>Constraints</h3></td></tr><tr><td align="center" valign="top">-</td><td><b>num</b> will contain between <b>2</b> and <b>20</b> elements, inclusive.</td></tr><tr><td align="center" valign="top">-</td><td>Each element of <b>num</b> will be between <b>1</b> and <b>n-1</b>, inclusive.</td></tr><tr><td colspan="2"><h3>Examples</h3></td></tr><tr><td align="center" nowrap="true">0)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 2, 1}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2">One possible solution is that vampire 1 is the True Ancestor, and vampires 0 and 2 are its servants.</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">1)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{2, 2, 2}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2">At least two of the vampires must have two servants, but there needs to be at least 5 vampires for such a situation to happen (excluding the True Ancestor).</td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">2)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 1, 1, 4}</pre></td></tr></table></td></tr><tr><td><pre>Returns: 2</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr><tr><td align="center" nowrap="true">3)</td><td></td></tr><tr><td>&#160;&#160;&#160;&#160;</td><td><table><tr><td><table><tr><td><pre>{1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}</pre></td></tr></table></td></tr><tr><td><pre>Returns: -1</pre></td></tr><tr><td><table><tr><td colspan="2"></td></tr></table></td></tr></table></td></tr></table><p>This problem statement is the exclusive and proprietary property of TopCoder, Inc.  Any unauthorized use or reproduction of this information without the prior written consent of TopCoder, Inc. is strictly prohibited.  (c)2003, TopCoder, Inc.  All rights reserved.  </p></body></html>
